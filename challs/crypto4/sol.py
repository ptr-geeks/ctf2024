import Crypto.Util.number as number

key1 = 116989067918297905751706411685893940559507374551983734621221857383098859622633766699108463817101829507095222099127270462316334219430512983962840187981853316916543651063593675640681444752530615247077955534257159467181774633362500486638334709827687325766928795591243535892579020129511225600466548013729528309813
key2 = 101130256487966025404838748512790833721489192886012683919990928752107972557803668236492404747017500408939886334798483710047399389126664889661559721191539522689409907013684505423213865032209579334836125044949129314804582910065821983674927798450910975034843488148665950891574770243498367521966577720085457637307
key3 = 90085710239355249679546724877950775234728789008950254479371453524184471179819782547859177278171236574906171913559839480526852064333181798618028658010264202429920224155694009202615406988669966926656782159376087456886277914918440806897403399366746889499324175534379347137974733726372187978110127418437003284451
c1 = 10426323187837137396628973304346063751278255265834171404390487618980478136445734340814904940476837071383371965908533260874760703427135108966734238645916496686943654403085847828963330347813698567136863704699614919350631801095209264663756825695652268496314894181
c2 = 10426323187837137396628973304346063751278255265834171404390487618980478136445734340814904940476837071383371965908533260874760703427135108966734238645916496686943654403085847828963330347813698567136863704699614919350631801095209264663756825695652268496314894181
c3 = 10426323187837137396628973304346063751278255265834171404390487618980478136445734340814904940476837071383371965908533260874760703427135108966734238645916496686943654403085847828963330347813698567136863704699614919350631801095209264663756825695652268496314894181

def gcd_extended(a, b):
    if a == 0:
        return b, 0, 1
    gcd, x1, y1 = gcd_extended(b % a, a)
    x = y1 - (b // a) * x1
    y = x1
    return gcd, x, y

def nth_root(x, n):
    upper_bound = 1
    while upper_bound ** n <= x:
        upper_bound *= 2
    lower_bound = upper_bound // 2

    while lower_bound < upper_bound:
        mid = (lower_bound + upper_bound) // 2
        mid_nth = mid ** n
        if lower_bound < mid and mid_nth < x:
            lower_bound = mid
        elif upper_bound > mid and mid_nth > x:
            upper_bound = mid
        else:
            return mid
    return mid + 1

n = key1 * key2 * key3

m1 = n // key1
m2 = n // key2
m3 = n // key3

_, x1, _ = gcd_extended(m1, key1)
_, x2, _ = gcd_extended(m2, key2)
_, x3, _ = gcd_extended(m3, key3)

res = c1 * x1 * m1 + c2 * x2 * m2 + c3 * x3 * m3
res = res % n
res = nth_root(res, 3)

print(number.long_to_bytes(res))
